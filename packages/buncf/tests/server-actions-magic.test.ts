import { describe, test, expect, mock } from "bun:test";
import { createApp } from "../src/router";
import { defineAction } from "../src/action";
import { z } from "zod";
import * as fs from "fs";

// Mock prodActions since it's normally generated by build
const mockAction = defineAction(
  z.object({ name: z.string() }),
  async ({ name }) => ({ greeting: `Hello ${name}` })
);

// We'll mock the registry module by injecting it via global/import scope if possible, 
// or simply testing the createApp with a custom registry if we could.
// Current createApp usesprodActions from "../actions-registry".

describe("Magic Server Actions Integration", () => {

  test("direct call support (client-side style)", async () => {
    const action = defineAction(
      z.object({ x: z.number() }),
      async ({ x }) => x * 2
    );

    // In actual client build, this logic is replaced by fetch,
    // but the type-system and the hybrid function in development 
    // allow calling the handler directly (with a mock ctx if needed).
    // Our refactored defineAction returns a function that calls the handler.
    const result = await action({ x: 21 });
    expect(result).toBe(42);
  });

  test("router handles /_action/ requests specifically", async () => {
    // Note: To test this properly without a real registry, 
    // we need to trigger the "Dev Mode" resolution in router/index.ts

    const { fetch } = createApp();

    // We'll simulate a dev mode request for a file that exists
    // We need to create a temporary .action.ts file
    const tempFile = "magic-test.action.ts";
    fs.writeFileSync(tempFile, `
      import { defineAction } from "./src/action";
      import { z } from "zod";
      export const testAction = defineAction(z.object({ v: z.number() }), async ({v}) => ({ res: v + 1 }));
    `);

    try {
      // actionId = filePath::exportName
      const actionId = encodeURIComponent(`${tempFile}::testAction`);
      const req = new Request(`http://localhost/_action/${actionId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ v: 99 })
      });

      const res = await fetch(req);
      expect(res.status).toBe(200);
      const json = await res.json();
      expect(json.res).toBe(100);
    } finally {
      if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
    }
  });

  test("returns 404 for invalid action separator", async () => {
    const { fetch } = createApp();
    const req = new Request(`http://localhost/_action/invalid-format`, {
      method: "POST"
    });
    const res = await fetch(req);
    expect(res.status).toBe(404);
  });

  test("returns 404 for non-existent action file", async () => {
    const { fetch } = createApp();
    const actionId = encodeURIComponent("ghost.action.ts::nothing");
    const req = new Request(`http://localhost/_action/${actionId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({})
    });
    const res = await fetch(req);
    expect(res.status).toBe(404);
  });
});
