import * as fs from "fs";
import * as path from "path";
// @ts-ignore
import { log } from "./log";

export async function generateRoutesManifest() {
  log.step("üó∫Ô∏è Generating client routes manifest (.buncf/routes.ts)...");
  const stats = {
    staticRoutes: 0,
    dynamicRoutes: 0,
    layouts: 0,
    total: 0,
    manifest: [] as Array<{ path: string, type: "Static" | "Dynamic" }>
  };

  try {
    const pagesDir = path.resolve(process.cwd(), "src/pages");
    let routeEntries: string[] = [];
    let layoutEntries: string[] = [];

    if (fs.existsSync(pagesDir)) {
      const glob = new Bun.Glob("**/*.{tsx,jsx,ts,js}");
      const files: string[] = [];
      for await (const file of glob.scan({ cwd: pagesDir, onlyFiles: true })) {
        files.push(file);
      }
      // Ensure deterministic order
      files.sort();

      routeEntries = files.map((file) => {
        const absFile = path.resolve(pagesDir, file);
        let routePath = file.replace(/\.(tsx|jsx|ts|js)$/, "");
        if (routePath.endsWith("index")) routePath = routePath.slice(0, -5);
        if (routePath.endsWith("/")) routePath = routePath.slice(0, -1);
        routePath = "/" + routePath.split(path.sep).join("/");
        if (routePath === "") routePath = "/";
        if (routePath.length > 1 && routePath.endsWith("/")) routePath = routePath.slice(0, -1);
        routePath = routePath.replace(/\/+/g, "/");

        if (routePath.includes("[") || routePath.includes("*")) stats.dynamicRoutes++;
        else stats.staticRoutes++;

        const relPath = path.relative(".buncf", absFile).split(path.sep).join(path.posix.sep);
        const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;

        stats.manifest.push({ path: routePath, type: routePath.includes("[") || routePath.includes("*") ? "Dynamic" : "Static" });

        return `  "${routePath}": () => import("${importPath}")`;
      });

      const specialPages = ["_error", "_loading", "_notfound"];
      for (const page of specialPages) {
        let ext = ["tsx", "jsx", "ts", "js"].find(e => fs.existsSync(path.join(pagesDir, `${page}.${e}`)));
        let searchDir = pagesDir;

        if (!ext) {
          const srcDir = path.resolve(process.cwd(), "src");
          ext = ["tsx", "jsx", "ts", "js"].find(e => fs.existsSync(path.join(srcDir, `${page}.${e}`)));
          if (ext) searchDir = srcDir;
        }

        if (ext) {
          const fullPath = path.join(searchDir, `${page}.${ext}`);
          const relPath = path.relative(path.resolve(".buncf"), fullPath).split(path.sep).join(path.posix.sep);
          const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;
          routeEntries.push(`  "/${page}": () => import("${importPath}")`);
          stats.staticRoutes++;
        }
      }

      const scanLayouts = async (dir: string, baseRoute: string) => {
        const files = await fs.promises.readdir(dir);
        await Promise.all(files.map(async (file) => {
          const fullPath = path.join(dir, file);
          const stat = await fs.promises.stat(fullPath);
          if (stat.isDirectory()) {
            await scanLayouts(fullPath, `${baseRoute}/${file}`);
          } else if (file.match(/^_layout\.(tsx|jsx|ts|js)$/)) {
            let routeKey = baseRoute === "" ? "/" : baseRoute;
            if (!routeKey.startsWith("/")) routeKey = "/" + routeKey;

            const relPath = path.relative(path.resolve(".buncf"), fullPath).split(path.sep).join(path.posix.sep);
            const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;
            layoutEntries.push(`  "${routeKey}": () => import("${importPath}")`);
            stats.layouts++;
          }
        }));
      };
      await scanLayouts(pagesDir, "");
      layoutEntries.sort();
    }

    const routesContent = `
/**
 * Auto-generated by buncf
 */
import { type ComponentType } from "react";

export const routes: Record<string, () => Promise<{ default: ComponentType<any> }>> = {
${routeEntries.join(",\n")}
};

export const layouts: Record<string, () => Promise<{ default: ComponentType<any> }>> = {
${layoutEntries.join(",\n")}
};

declare module "buncf" {
  interface BuncfTypeRegistry {
    routes: {
${routeEntries.map(e => e.split(":")[0]).filter(key => !key?.includes("[")).map(key => `      ${key}: true;`).join("\n")}
    };
  }
}
`;
    if (!fs.existsSync(".buncf")) fs.mkdirSync(".buncf");
    await Bun.write(".buncf/routes.ts", routesContent);
    stats.total = stats.staticRoutes + stats.dynamicRoutes;
    return stats;
  } catch (e) {
    console.error("Failed to generate routes manifest:", e);
    return stats;
  }
}
