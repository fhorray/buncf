import * as fs from "fs";
import * as path from "path";
import { scanLayouts } from "./scan-layouts";
// @ts-ignore
import { log } from "./log";

export async function generateRoutesManifest() {
  log.step("üó∫Ô∏è Generating client routes manifest (.buncf/routes.ts)...");
  const stats = {
    staticRoutes: 0,
    dynamicRoutes: 0,
    layouts: 0,
    total: 0,
    manifest: [] as Array<{ path: string, type: "Static" | "Dynamic" }>
  };

  try {
    const pagesDir = path.resolve(process.cwd(), "src/pages");
    let routeEntries: string[] = [];
    let layoutEntries: string[] = [];

    if (fs.existsSync(pagesDir)) {
      const glob = new Bun.Glob("**/*.{tsx,jsx,ts,js}");
      const files: string[] = [];
      for await (const file of glob.scan({ cwd: pagesDir, onlyFiles: true })) {
        files.push(file);
      }
      // Ensure deterministic order
      files.sort();

      routeEntries = files.map((file) => {
        const absFile = path.resolve(pagesDir, file);
        let routePath = file.replace(/\.(tsx|jsx|ts|js)$/, "");
        if (routePath.endsWith("index")) routePath = routePath.slice(0, -5);
        if (routePath.endsWith("/")) routePath = routePath.slice(0, -1);
        routePath = "/" + routePath.split(path.sep).join("/");
        if (routePath === "") routePath = "/";
        if (routePath.length > 1 && routePath.endsWith("/")) routePath = routePath.slice(0, -1);
        routePath = routePath.replace(/\/+/g, "/");

        if (routePath.includes("[") || routePath.includes("*")) stats.dynamicRoutes++;
        else stats.staticRoutes++;

        const relPath = path.relative(".buncf", absFile).split(path.sep).join(path.posix.sep);
        const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;

        stats.manifest.push({ path: routePath, type: routePath.includes("[") || routePath.includes("*") ? "Dynamic" : "Static" });

        return `  "${routePath}": () => import("${importPath}")`;
      });

      const specialPages = ["_error", "_loading", "_notfound"];
      for (const page of specialPages) {
        let ext = ["tsx", "jsx", "ts", "js"].find(e => fs.existsSync(path.join(pagesDir, `${page}.${e}`)));
        let searchDir = pagesDir;

        if (!ext) {
          const srcDir = path.resolve(process.cwd(), "src");
          ext = ["tsx", "jsx", "ts", "js"].find(e => fs.existsSync(path.join(srcDir, `${page}.${e}`)));
          if (ext) searchDir = srcDir;
        }

        if (ext) {
          const fullPath = path.join(searchDir, `${page}.${ext}`);
          const relPath = path.relative(path.resolve(".buncf"), fullPath).split(path.sep).join(path.posix.sep);
          const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;
          routeEntries.push(`  "/${page}": () => import("${importPath}")`);
          stats.staticRoutes++;
        }
      }

      const layouts = await scanLayouts(pagesDir);
      for (const layout of layouts) {
        const relPath = path.relative(path.resolve(".buncf"), layout.filepath).split(path.sep).join(path.posix.sep);
        const importPath = relPath.startsWith(".") ? relPath : `./${relPath}`;
        layoutEntries.push(`  "${layout.route}": () => import("${importPath}")`);
        stats.layouts++;
      }
    }

    const routesContent = `
/**
 * Auto-generated by buncf
 */
import { type ComponentType } from "react";

export const routes: Record<string, () => Promise<{ default: ComponentType<any> }>> = {
${routeEntries.join(",\n")}
};

export const layouts: Record<string, () => Promise<{ default: ComponentType<any> }>> = {
${layoutEntries.join(",\n")}
};

declare module "buncf" {
  interface BuncfTypeRegistry {
    routes: {
${routeEntries.map(e => e.split(":")[0]).filter(key => !key?.includes("[")).map(key => `      ${key}: true;`).join("\n")}
    };
  }
}
`;
    if (!fs.existsSync(".buncf")) fs.mkdirSync(".buncf");
    await Bun.write(".buncf/routes.ts", routesContent);
    stats.total = stats.staticRoutes + stats.dynamicRoutes;
    return stats;
  } catch (e) {
    console.error("Failed to generate routes manifest:", e);
    return stats;
  }
}
