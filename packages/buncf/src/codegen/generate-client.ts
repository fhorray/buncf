/**
 * API Client Generator - Creates typed fetch wrapper
 * 
 * Generates a Hono-like API client with full type inference:
 * api.get("/users/:id", { params: { id: "1" } })
 */

import * as fs from "fs";
import * as path from "path";
import { type RouteTypeInfo } from "./api-scanner";

/**
 * Generates the content of .buncf/api-client.ts
 */
export function generateClientContent(): string {
  return `/**
 * Auto-generated by buncf
 * Type-safe API client with Hono-like syntax
 * 
 * Usage:
 * import { api } from "./.buncf/api-client";
 * const user = await api.get("/users/:id", { params: { id: "1" } });
 */

import type { ApiRoutes } from "./api-types";

// Helper types for extracting route metadata
type RouteMethod<P extends keyof ApiRoutes, M extends string> = 
  M extends keyof ApiRoutes[P] ? ApiRoutes[P][M] : never;

type ExtractParams<T> = T extends { params: infer P } ? P : never;
type ExtractBody<T> = T extends { body: infer B } ? B : never;
type ExtractResponse<T> = T extends { response: infer R } ? R : never;

// Routes that have a specific method
type RoutesWithMethod<M extends string> = {
  [K in keyof ApiRoutes]: M extends keyof ApiRoutes[K] ? K : never;
}[keyof ApiRoutes];

// Options type based on route requirements
type RequestOptions<P extends keyof ApiRoutes, M extends string> = 
  (ExtractParams<RouteMethod<P, M>> extends never ? {} : { params: ExtractParams<RouteMethod<P, M>> }) &
  (ExtractBody<RouteMethod<P, M>> extends never ? {} : { body: ExtractBody<RouteMethod<P, M>> });

/**
 * Interpolates path parameters
 * "/users/:id" + { id: "1" } -> "/users/1"
 */
function interpolatePath(path: string, params?: Record<string, string>): string {
  if (!params) return path;
  return path.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, (_, key) => params[key] ?? "");
}

/**
 * Type-safe API client
 */
export const api = {
  /**
   * GET request with typed response
   */
  async get<P extends RoutesWithMethod<"GET">>(
    path: P,
    options?: RequestOptions<P, "GET">
  ): Promise<ExtractResponse<RouteMethod<P, "GET">>> {
    const url = interpolatePath(path as string, (options as any)?.params);
    const res = await fetch(url);
    if (!res.ok) throw new Error(\`API Error: \${res.status}\`);
    return res.json();
  },

  /**
   * POST request with typed body and response
   */
  async post<P extends RoutesWithMethod<"POST">>(
    path: P,
    options: RequestOptions<P, "POST">
  ): Promise<ExtractResponse<RouteMethod<P, "POST">>> {
    const url = interpolatePath(path as string, (options as any)?.params);
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify((options as any)?.body)
    });
    if (!res.ok) throw new Error(\`API Error: \${res.status}\`);
    return res.json();
  },

  /**
   * PUT request with typed body and response
   */
  async put<P extends RoutesWithMethod<"PUT">>(
    path: P,
    options: RequestOptions<P, "PUT">
  ): Promise<ExtractResponse<RouteMethod<P, "PUT">>> {
    const url = interpolatePath(path as string, (options as any)?.params);
    const res = await fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify((options as any)?.body)
    });
    if (!res.ok) throw new Error(\`API Error: \${res.status}\`);
    return res.json();
  },

  /**
   * PATCH request with typed body and response
   */
  async patch<P extends RoutesWithMethod<"PATCH">>(
    path: P,
    options: RequestOptions<P, "PATCH">
  ): Promise<ExtractResponse<RouteMethod<P, "PATCH">>> {
    const url = interpolatePath(path as string, (options as any)?.params);
    const res = await fetch(url, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify((options as any)?.body)
    });
    if (!res.ok) throw new Error(\`API Error: \${res.status}\`);
    return res.json();
  },

  /**
   * DELETE request with typed response
   */
  async delete<P extends RoutesWithMethod<"DELETE">>(
    path: P,
    options?: RequestOptions<P, "DELETE">
  ): Promise<ExtractResponse<RouteMethod<P, "DELETE">>> {
    const url = interpolatePath(path as string, (options as any)?.params);
    const res = await fetch(url, { method: "DELETE" });
    if (!res.ok) throw new Error(\`API Error: \${res.status}\`);
    return res.json();
  }
};
`;
}

/**
 * Generates .buncf/api-client.ts
 */
export async function generateApiClient(outputDir: string): Promise<void> {
  const content = generateClientContent();
  const outputPath = path.join(outputDir, "api-client.ts");

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  await Bun.write(outputPath, content);
}
