/**
 * Buncf Router - Client-side Provider
 *
 * Handles navigation, route matching, and dynamic page importing on the client.
 */

import React, {
  useState,
  useEffect,
  type ReactNode,
  type ComponentType,
} from 'react';
import { routerStore, type RouteState } from './client';

export interface PageProps {
  params: Record<string, string>;
  query: Record<string, string>;
}

export interface RouterProviderProps {
  /**
   * Root layout component
   * Wraps every page
   */
  layout?: ComponentType<{ children: ReactNode }>;

  /**
   * Map of route patterns to dynamic imports
   * Automatically generated by buncf dev
   */
  routes?: Record<string, () => Promise<{ default: ComponentType<any> }>>;
}

/**
 * 404 Page Component
 */
function NotFoundPage() {
  return (
    <div
      style={{ padding: '40px', fontFamily: 'sans-serif', textAlign: 'center' }}
    >
      <h1 style={{ color: '#e11d48', fontSize: '2rem' }}>
        404 - Page Not Found
      </h1>
      <p style={{ color: '#4b5563' }}>
        The page you are looking for does not exist.
      </p>
      <a href="/" style={{ color: '#2563eb', textDecoration: 'underline' }}>
        Go Home
      </a>
    </div>
  );
}

/**
 * Error Page Component
 * Shown when setup is incorrect or page fails to load
 */
function ErrorPage({ error }: { error: Error }) {
  return (
    <div style={{ padding: '40px', fontFamily: 'sans-serif' }}>
      <h1 style={{ color: '#e11d48' }}>Something went wrong</h1>
      <pre
        style={{
          background: '#f3f4f6',
          padding: '20px',
          borderRadius: '8px',
          overflowX: 'auto',
        }}
      >
        {error.message}
      </pre>
    </div>
  );
}

/**
 * Buncf Router Component
 *
 * Usage:
 * ```tsx
 * import { BuncfRouter } from "buncf/router";
 * import Layout from "./_layout";
 *
 * // Routes are usually auto-injected by the build process
 * // based on file-system structure
 *
 * <BuncfRouter layout={Layout} />
 * ```
 */
export function BuncfRouter({
  layout: Layout,
  routes = {},
}: RouterProviderProps) {
  const [route, setRoute] = useState<RouteState>(routerStore.getState());
  const [PageComponent, setPageComponent] = useState<ComponentType<any> | null>(
    null,
  );
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(false);

  // Track current pathname to prevent loops
  const currentPathRef = React.useRef(routerStore.getState().pathname);

  // Subscribe to router store updates
  useEffect(() => {
    const unsubscribe = routerStore.subscribe((state) => {
      setRoute(state);
      // Only reload page if pathname changed
      if (state.pathname !== currentPathRef.current) {
         currentPathRef.current = state.pathname;
         loadPage(state.pathname);
      }
    });
    return () => {
      unsubscribe();
    };
  }, []);

  // Initial load
  useEffect(() => {
    loadPage(route.pathname);
  }, []);

  async function loadPage(pathname: string) {
    setError(null);
    setLoading(true);

    try {
      // 1. Find matching route
      let importer = routes[pathname];
      let matchedParams: Record<string, string> = {};

      // Try resolving index or trailing slash variations
      if (!importer) {
        if (pathname === '/') importer = routes['/index'];
        else if (pathname.endsWith('/')) importer = routes[pathname.slice(0, -1)];
        else importer = routes[`${pathname}/`];
      }

      // Dynamic Route Matching
      if (!importer) {
        const routeKeys = Object.keys(routes);
        
        // Sort keys to prioritize specific routes over catch-alls
        // [param] (dynamic) vs [...param] (catch-all)
        // More specific first.
        routeKeys.sort((a, b) => {
           const aCatchAll = a.includes('[...');
           const bCatchAll = b.includes('[...');
           if (aCatchAll && !bCatchAll) return 1;
           if (!aCatchAll && bCatchAll) return -1;
           return 0;
        });

        for (const key of routeKeys) {
          // Convert /blog/[slug] to regex: ^/blog/([^/]+)$
          // Escape special chars except brackets
          if (!key.includes('[') && !key.includes('*')) continue; // optimization: only check dynamic routes

          const paramNames: string[] = [];
          
          // Escape regex special chars helper
          const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

          // Build regex similar to matcher.ts logic
          // Strategy: Split by dynamic segments, escape static parts, then join.
          const segments = [];
          let lastIndex = 0;
          const placerRegex = /(\[\.\.\.([a-zA-Z0-9_]+)\])|(\[([a-zA-Z0-9_]+)\])|(:([a-zA-Z0-9_]+))/g;
          let matchRegex;
          
          while ((matchRegex = placerRegex.exec(key)) !== null) {
            // Static content before this match
            const staticPart = key.slice(lastIndex, matchRegex.index);
            if (staticPart) segments.push(escapeRegex(staticPart));
            
            if (matchRegex[2]) {
              // [...param] -> (.*)
              paramNames.push(matchRegex[2]);
              segments.push('(.*)');
            } else if (matchRegex[4]) {
               // [param] -> ([^/]+)
               paramNames.push(matchRegex[4]);
               segments.push('([^/]+)');
            } else if (matchRegex[6]) {
               // :param -> ([^/]+)
               paramNames.push(matchRegex[6]);
               segments.push('([^/]+)');
            }
            lastIndex = placerRegex.lastIndex;
          }
          
          // Remaining static content
          const remaining = key.slice(lastIndex);
          if (remaining) segments.push(escapeRegex(remaining));
          
          const regexStr = segments.join('');
          
          const regex = new RegExp(`^${regexStr}/?$`); // Allow optional trailing slash
          const match = pathname.match(regex);
          
          if (match) {
            importer = routes[key];
            match.slice(1).forEach((val, i) => {
              const paramName = paramNames[i];
              if (paramName) {
                matchedParams[paramName] = decodeURIComponent(val || '');
              }
            });
            break; 
          }
        }
      }

      if (!importer) {
         // Fallback: Use injected server-side match if available and exact
         // (Only useful if client has no map but server knew it? Unlikely with current architecture)
         setPageComponent(() => NotFoundPage);
         return;
      }

      // Update params in store if we found new ones
      if (Object.keys(matchedParams).length > 0) {
        routerStore.setParams(matchedParams);
      } else {
        // Ensure params are cleared if no match (e.g. going from /blog/1 to /about)
        // routerStore.setParams({}); 
      }

      // 2. Import page component
      const module = await importer();
      if (!module.default) {
        throw new Error(
          `Page at ${pathname} does not export a default component`,
        );
      }

      setPageComponent(() => module.default);
    } catch (err: any) {
      console.error('[buncf] Failed to load page:', err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }

  // Render
  if (error) {
    if (Layout) {
      return (
        <Layout>
          <ErrorPage error={error} />
        </Layout>
      );
    }
    return <ErrorPage error={error} />;
  }

  const Content = PageComponent ? (
    <PageComponent params={route.params} query={route.query} />
  ) : (
    // Only show loading if taking too long, or custom loading
    <div />
  );

  if (Layout) {
    return <Layout>{Content}</Layout>;
  }

  return Content;
}
